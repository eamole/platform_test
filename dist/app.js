// Generated by CoffeeScript 1.9.3

/*
	bollix
	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
	need to create a generic node and cast it - by changing the prototype!!
 */

(function() {
  var Base, Node, Poller, Template, TestView, View, Watcher, util, watcher,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("are we starting?");

  View.show("TestView");

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  util = require("util");


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  module.exports.Node = Node;

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("are we starting?");

  View.show("TestView");

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  util = require("util");


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  module.exports.Node = Node;

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  console.log("are we starting?");

  View.show("TestView");

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  util = require("util");


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  module.exports.Node = Node;

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("are we starting?");

  View.show("TestView");

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  util = require("util");


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  module.exports.Node = Node;

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  console.log("are we starting?");

  View.show("TestView");

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();

  util = require("util");


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  module.exports.Node = Node;

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("are we starting?");

  View.show("TestView");

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  console.log("are we starting?");

  View.show("TestView");

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  console.log("are we starting?");

  View.show("TestView");

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

  Base = (function() {
    function Base(class_name) {
      this.class_name = class_name;
      this.trace = bind(this.trace, this);
      this.warn = bind(this.warn, this);
      this.error = bind(this.error, this);
    }

    Base.prototype.error = function(msg) {
      return console.log("error [" + this.class_name + "]: " + msg);
    };

    Base.prototype.warn = function(msg) {
      return console.log("warning [" + this.class_name + "]: " + msg);
    };

    Base.prototype.trace = function(msg) {
      return console.log("trace [" + this.class_name + "]: " + msg);
    };

    return Base;

  })();


  /*
  	bollix
  	fstat causes a break : it returns the stats for the object - but we do not know in advance if the object is a file or folder!!
  	need to create a generic node and cast it - by changing the prototype!!
   */

  Node = (function() {
    function Node(parent, path1) {
      this.parent = parent;
      this.path = path1;
      this.signal = bind(this.signal, this);
      this.onUpdateGetDir = bind(this.onUpdateGetDir, this);
      this.onInitialGetDir = bind(this.onInitialGetDir, this);
      this.onUpdateGetStats = bind(this.onUpdateGetStats, this);
      this.onInitialGetStats = bind(this.onInitialGetStats, this);
      this.remove = bind(this.remove, this);
      this.check = bind(this.check, this);
      console.log("parent : " + this.parent + " path : " + this.path);
      this.lupdate = 0;
      this.type = "unkown";
      this.nodes = {};
      fs.stat(this.path, this.onInitialGetStats);
    }

    Node.prototype.check = function() {
      var i, len, node, path, ref, results;
      fs.stat(this.path, this.onUpdateGetStats);
      ref = this.nodes;
      results = [];
      for (path = i = 0, len = ref.length; i < len; path = ++i) {
        node = ref[path];
        results.push(node.check());
      }
      return results;
    };

    Node.prototype.remove = function(key, node) {
      return delete this.nodes[key];
    };

    Node.prototype.onInitialGetStats = function(err, stats) {
      console.log("Stats");
      console.log(stats);
      if (!err) {
        this.lupdate = Math.floor(stats.ctime.getTime() / could(use(mtime)));
        if (stats.isFile()) {
          this.type = "file";
        } else if (stats.isDirectory()) {
          this.type = "folder";
          fs.readdir(this.path, this.onInitialGetDir);
        } else {
          this.signal("ignore unwatched type " + this.path);
          this.parent.remove(this.path, this);
        }
        return this.signal("add", this.lupdate);
      }
    };

    Node.prototype.onUpdateGetStats = function(err, stats) {
      var time;
      if (!err) {
        time = stats.ctime.getTime();
        if (stats.isFile()) {
          if (this.lupdate === 0) {
            this.signal("add", time);
          } else if (time > this.lupdate) {
            this.signal("update", time);
          }
          return this.lupdate = time;
        } else if (stats.isDirectory()) {
          return this.signal("add", time);
        }
      }
    };

    Node.prototype.onInitialGetDir = function(err, files) {
      var file, i, len, results;
      if (!err) {
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(this.nodes[file] = new Node(this, file));
        }
        return results;
      }
    };

    Node.prototype.onUpdateGetDir = function(err, files) {
      var file, i, j, key, len, len1, node, ref, ref1, results;
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        if (this.nodes[file]) {
          this.nodes[file].check();
        } else {
          this.nodes[file] = new Node(this, file);
        }
      }
      ref = this.nodes;
      results = [];
      for (key = j = 0, len1 = ref.length; j < len1; key = ++j) {
        node = ref[key];
        if (ref1 = !key, indexOf.call(files, ref1) >= 0) {
          delete this.nodes[key];
          results.push(node.signal("deleted"));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Node.prototype.signal = function(evt, time) {
      var ref;
      if ((ref = this.parent) != null) {
        ref.signal(this, evt, time != null);
      }
      return console.log(this.path + ("event " + evt + " time " + (time != null) + " path " + this.path));
    };

    return Node;

  })();

  Poller = (function(superClass) {
    extend(Poller, superClass);

    function Poller(cfg) {
      this.stop = bind(this.stop, this);
      this.tick = bind(this.tick, this);
      this.maxCount = 0;
      this.cb = cfg.handler != null;
      this.freq = cfg.freq != null;
      this.maxCount = cfg.maxCount != null;
      this.count = 0;
      setTimeout(this.tick, this.freq);
    }

    Poller.prototype.tick = function() {
      var ok;
      this.count++;
      if (this.count > this.maxCount) {
        this.stop("maxCount exceeded");
      }
      ok = this.cb();
      if (ok != null) {
        return setTimeout(this.tick, this.freq);
      } else {
        return this.stop("callback returned null");
      }
    };

    Poller.prototype.stop = function(reason) {
      return this.trace("finishing polling because " + reason);
    };

    return Poller;

  })(Base);

  console.log("Watcher : " + Watcher);

  console.log(Watcher);

  watcher = new Watcher({
    ignores: [".git", "node_modules"],
    folders: ["."]
  });

  console.log("are we starting?");

  View.show("TestView");

  Template = (function(superClass) {
    extend(Template, superClass);

    function Template(name) {
      this.render = bind(this.render, this);
      Template.__super__.constructor.call(this, "Template " + name);
    }

    Template.prototype.render = function(data) {
      var prop, val;
      for (prop in data) {
        val = data[prop];
        this.prop = val;
      }
      return "";
    };

    return Template;

  })(Base);

  TestView = (function(superClass) {
    extend(TestView, superClass);

    function TestView() {
      this.render = bind(this.render, this);
      this.init = bind(this.init, this);
      TestView.__super__.constructor.call(this, "TestView");
    }

    TestView.prototype.init = function(data) {
      return TestView.__super__.init.call(this, data);
    };

    TestView.prototype.render = function(data) {
      TestView.__super__.render.call(this, data);
      return "\nHello World from " + this.name + "\n";
    };

    return TestView;

  })(View);

  View = (function(superClass) {
    extend(View, superClass);

    View.prototype.views = {};

    View.show = function(name, data) {
      var html, view;
      console.log("view name : " + name + " ");
      view = new window[name];
      View.views[name] = view;
      view.init(data);
      html = view.render();
      return $("main-container").html(html);
    };

    function View(name1) {
      this.name = name1;
      this.render = bind(this.render, this);
      this.$ = bind(this.$, this);
      this.onDomReady = bind(this.onDomReady, this);
      this.ebind = bind(this.ebind, this);
      this.pbind = bind(this.pbind, this);
      this.init = bind(this.init, this);
      this.events = {
        click: {},
        change: {}
      };
      this.domBindings = {
        props: {},
        els: {}
      };
      this.propChangePollerRequired = false;
      $(function() {
        return this.onDomReady;
      });
    }

    View.prototype.init = function(data) {
      var k, results, v;
      results = [];
      for (k in data) {
        v = data[k];
        results.push(this[k] = v);
      }
      return results;
    };

    View.prototype.pbind = function(prop, id) {
      return this.domBindings.props[prop] = id;
    };

    View.prototype.ebind = function(id, prop) {
      return this.domBindings.els[id] = prop;
    };

    View.prototype.onDomReady = function() {
      var el, handler, i, id, j, len, len1, prop, ref, ref1, ref2, ref3, sel, self;
      self = this;
      ref = this.domBindings.els;
      for (prop = i = 0, len = ref.length; i < len; prop = ++i) {
        id = ref[prop];
        el = this.$(id);
        this.events.change[id] = function() {
          return self[prop] = this.val;
        };
      }
      ref1 = this.domBindings.props;
      for (prop = j = 0, len1 = ref1.length; j < len1; prop = ++j) {
        id = ref1[prop];
        el = this.$(id);
        if (this[prop] == null) {
          this.error("invalid watched property " + prop);
        }
        if (this[prop] != null) {
          this.domBindings.vals[prop] = this[prop];
        }
        this.propChangePollerRequired = true;
      }
      ref2 = this.events.click;
      for (sel in ref2) {
        handler = ref2[sel];
        el = this.$(sel);
        el.click(function(evt) {
          return handler(this, evt);
        });
      }
      ref3 = this.events.change;
      for (sel in ref3) {
        handler = ref3[sel];
        el = this.$(sel);
        el.change(function(evt) {
          return handler(this, evt);
        });
      }
      return this.poller = new Poller({
        cb: checkProps
      });
    };


    /*
      we want some dom handling
     */

    View.prototype.$ = function(sel, val) {
      var els;
      els = $(sel);
      if (els.length === 0) {
        this.error("invalid selector " + sel);
      }
      if ((val != null) && (els.val != null)) {
        els.val(val);
      }
      if ((val != null) && (els.html != null)) {
        els.html(val);
      }
      if ((val != null) && !((els.html != null) || els.val)) {
        this.warn("value specified but no suitable update method " + sel + " ");
      }
      return $(els);
    };

    View.prototype.render = function(data) {
      View.__super__.render.call(this, data);
      return "";
    };

    return View;

  })(Template);

  Node = require("./node.js").Node;

  Watcher = (function() {
    function Watcher(args) {
      this.ignore = bind(this.ignore, this);
      var folder, i, len, ref;
      this.ignores = [];
      this.nodes = {};
      this.ignores = args.ignores != null;
      ref = args.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        if (!this.ignore(folder)) {
          this.nodes[folder] = new Node(this, folder);
        }
      }
    }

    Watcher.prototype.ignore = function(folder) {
      return indexOf.call(this.ignores, folder) >= 0;
    };

    return Watcher;

  })();

  module.exports.Watcher = Watcher;

}).call(this);

//# sourceMappingURL=app.js.map
